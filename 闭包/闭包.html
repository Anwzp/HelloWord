<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
闭包在JavaScript高级程序设计（178页）是这么解释的：闭包是指有权访问另一个函数作用域中的变量
<a href="http://www.jqhtml.com/15541.html">闭包的链接</a>
</body>
<script>
    //在说闭包之前先说下以及执行环境作用域以及作用域链
    //闭包是指函数对象可以通过作用域链相互关联起来，函数体内部的变量可以保存在函数作用域内。
    var color = 'red';

    function f() {
        var x=0;
        if (color !== 'red') {
            return 'blue'
        } else {
            return 'red';
        }
    }

    console.log(f())//red
    //执行环境定义了变量或函数有权访问的其他数据，决定可他们各自的行为，每个执行环境中都有与之关联的变量对象，环境中的所有变量和函数都保存在这个对象中
    //执行环境组成是{this：this，vo：变量对象，scopeChain：作用域链}
    //变量对象包括本执行环境的变量和函数名（代码执行时，需要什么先从这里寻找寻找不到则按照作用域链一步步往上寻找
    //作用域是指变量与函数的可访问范围，控制着变量及函数的可见性与生命周期。分为全局作用域和局部作用域。
    //全局作用域：
    //
    // 在代码中任何地方都能访问到的对象拥有全局作用域，有以下几种：
    //
    // 在最外层定义的变量；
    // 全局对象的属性
    // 任何地方隐式定义的变量（未定义直接赋值的变量），在任何地方隐式定义的变量都会定义在全局作用域中，
    // 即不通过 var 声明直接赋值的变量。
    // 局部作用域：
    //
    // JavaScript的作用域是通过函数来定义的，在一个函数中定义的变量只对这个函数内部可见，称为函数（局部）作用域
    //当函数需要访问自由变量时，会顺着作用域链来查找数据。子对象会一级一级的向上查找父对象的变量，父对象的变量对子对象是可见的，反之不成立。
    //作用域链就是在所有内部环境中查找变量的链式表。
    //作用域链是保证对执行环境有权访问的所有变量和函数的有序访问(JavaScript高级程序设计73页)
    //代码1
    function a() {
        var x = 0;
        return function () {
            x++;//此函数的作用域链能看到x
            console.log(x);
        }
    }

    var fun = a();//a返回的是个函数，保存起来没问题。
    fun()//打印1
    fun()//打印2

    //在创建一个预先包含全局变量对象的作用域链，这个作用域链被保存在内部的【【scope】】属性中，调用函数是创建一个执行环境，然后赋值scope属性中的对象构建起执行环境
    //的作用域链，此后又一个活动对象被创建并推注执行环境作用域链的前端。一般无论什么时候在函数中访问一个变量时。就会从作用域链中搜索具有相应名字的变量，一般函数执行
    // 完毕后，局部活动对象就会被销毁，内存中仅仅保存全局作用域，但闭包是另一个函数内部定义的函数会将包含函数的活动对象添加到他的作用域链，因此在内部定义的函数的作
    // 作用域链中实际上包含外部函数的活动对象，所以外部函数的活动对象在调用结束后并不会被销毁，直到匿名函数被销毁
    //javascript的垃圾回收机制时采用gc 。采用了标记清除或引用计数。（JavaScript高级程序设计第78页-80页）
    //标记清除 是指变量在进入执行环境时会被标记，在JavaScript垃圾回收机制运行时会去掉环境中的变量以及环境中引用的变量剩下的是将要删除的变量
    //引用计数 是指声明一个变量并将一个引用类型赋值给该变量时值的引用数就是一，当同一值又赋值给一个变量时引用数+1，相反当包含这个值得变量由
    // 取得其他值时，该变量引用数就-1当垃圾回收机
    // 运行时会释放引用数为0的值
</script>
</html>